#概述
垃圾收集器需要做的三件事情：
什么内存需要回收？
什么时候回收？
如何回收？  
对于java来说，垃圾收集器是用来回收堆内存与方法区内存的。
#垃圾收集算法
##标记-清除算法
##标记-整理算法
##标记-复制算法
##分代收集算法 
##hotsopt垃圾收集算法细节
1. 根节点枚举 
   枚举gcroot，暂停用户线程，枚举gcroot；gcroot主要包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（即一般说的Native方法）引用的对象。
   可以通过oomap加速gcroot枚举。
2. 安全点  
    程序不实在任意位置都可进行安全回收，只有在安全点才可进行垃圾回收。
3. 安全区域
   解决阻塞线程无法进入主动跑到安全点进行回收的问题。
4. 记忆集与卡表 
   非收集区到收集区的指针集合，用于记录非收集区的对象引用了收集区的对象，缩小gc的扫描范围，不需要将整个老年代加入到gcroot扫瞄范围中。
5. 写屏障
   保障卡表变脏与跨代引用的同时问题。  
5. 并发标记
   为了减少停顿时间，gc选择并发标记，即在用户线程运行的同时，gc线程进行标记。但是会造成并发标记时，用户线程修改了引用关系，导致的标记不准确问题。
   三色标记：白色、灰色、黑色。
   本该存活的对象标记为死亡的情况：  
   ![img_3.png](img_3.png)   
   当且仅当以下两个条件同时满足时，会产生“对象消失”的问 题，即原本应该是黑色的对象被误标为白色:   
   1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用;   
   2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。  
   翻译一下就是：在增加由已经扫描过的对象之像未被扫描的对象的同时，删除由正在扫描的对象到未扫描的引用。   
   解决方案：
      增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新
      插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫
      描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象
      了。查增 
      原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删
      除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描
      一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来
      进行搜索。补漏
      
#垃圾收集器
![img_4.png](img_4.png)

##Serial收集器    
![img_5.png](img_5.png)
##ParNew收集器
![img_6.png](img_6.png)
##Parallel Scavenge收集器
Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器。
Parallel Scavenge收集器的特点是：吞吐量优先。
![img_7.png](img_7.png)
##Parallel Old收集器
Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实 现。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相 当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old(PS
M arkSweep)收集器以外别无选择，其他表现良好的老年代收集器，如CM S无法与它配合工作。
![img_8.png](img_8.png)
##CMS收集器
![img_9.png](img_9.png)
##G1收集器
![img_10.png](img_10.png)
   
   
